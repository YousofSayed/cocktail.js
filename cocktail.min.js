"use strict"; export function $(t) { return document.querySelector(t) } export function $m(...t) { return t.map(t => document.querySelector(t)) } export function $a(t) { return document.querySelectorAll(t) } let _containerOFCocktailEvents_ = {}, _CocktailRoutes_; function excuteEvents(t = "*") { let e = document.querySelectorAll(t); e.forEach(t => { if ("true" === t.getAttribute("excuted")) return; let { attributes: e } = t;[...e].filter(t => t.name.startsWith("@")).forEach(e => { t.addEventListener(`${e.name.replace("@", "")}`, _containerOFCocktailEvents_[t.getAttribute(e.name)]), t.setAttribute("excuted", "true"), t.removeAttribute(e.name), delete _containerOFCocktailEvents_[t.getAttribute(e.name)] }) }) } function parseAndExcuteEventWhileInsert(t) { let e = parseToHTML(t).body; return [...e.querySelectorAll("*")].map(t => { let { attributes: e } = t; for (let r of [...e]) if (r.name.startsWith("@")) { t.setAttribute("excuted", "false"); break } return t }), e.innerHTML } export function useMap(t, e) { return parseToHTML(t.map((t, r) => e(t, r)).join("")).body.innerHTML } export function dff(t) { let e = encode(uniqueID()); return _containerOFCocktailEvents_[e] = t, e } export function insertInBegin(t, e) { let r = document.querySelector(t), n = parseAndExcuteEventWhileInsert(e); r?.insertAdjacentHTML("afterbegin", n), excuteEvents(`${t} [excuted="false"]`) } export function insertInEnd(t, e) { let r = document.querySelector(t), n = parseAndExcuteEventWhileInsert(e); r?.insertAdjacentHTML("beforeend", n), excuteEvents(`${t} [excuted="false"]`) } let arr = [1, 2, 5, 3, 4].splice(1); console.log(arr); export function replaceAndCommitAll(t, e, r) { let n = document.querySelectorAll(t); if (!n) throw Error(`Your element root "${t}" is ${n}`); n.forEach(n => { let a = n.innerHTML.replace(e, r); render(t, a) }) } export function replaceAndCommit(t, e, r) { let n = document.querySelector(t); if (!n) throw Error(`Your element root "${t}" is ${n}`); let a = n.innerHTML.replace(e, r); render(t, a) } export function parseToHTML(t) { return new DOMParser().parseFromString(t, "text/html") } export function render(t, e) { let r = document.querySelector(t); if (!r) throw Error(`Your element root "${t}" is ${r}`); let n = document.createElement("template"); "object" == typeof e ? (n.innerHTML += e.html, e.onBeforeMounted && e.onBeforeMounted(), r.innerHTML = n.innerHTML, e.onAfterMounted && e.onAfterMounted()) : (n.innerHTML += e, r.innerHTML = n.innerHTML), excuteEvents(`${t} *`) } export function useRouter(t, e) { let r = /(\/)?(\:)?(\w+)?/ig; _CocktailRoutes_ = cloneObject(e); let n = () => { let a = document.querySelectorAll("c-a"), { pathname: i } = location; a.forEach(a => { a.addEventListener("click", () => { let o = a.getAttribute("to") || ""; if (!o) throw Error('Route not founded , try to set "to" attribute at "<c-a>" element'); if (i != o) { for (let s in e["/404"] = e[o] || e["/404"] ? e["/404"] : "404 page not founded..:(", e) { let c = s?.match(r) || [], l = o.match(r) || []; c[0] === l[0] && (history.pushState(null, "", o), render(t, isFunction(e[s]) ? e[s]() : e[s])) } n() } }) }) }; function a() { let { pathname: a } = location; for (let i in e["/404"] = e[a] || e["/404"] ? e["/404"] : "404 page not founded..:(", e) { let o = i?.match(r) || [], s = a.match(r) || []; o[0] == s[0] && render(t, isFunction(e[i]) ? e[i]() : e[i]) } n() } n(), window.addEventListener("popstate", () => { a() }), window.addEventListener("load", () => { a() }) } export function useParams() { let t = /\/(\:)?(\w+)?/ig, e = cloneObject(_CocktailRoutes_), { pathname: r } = location, n = {}; return Object.keys(e).map(e => { let a = e.match(t) || [], i = r.match(t) || []; a[0] == i[0] && a.forEach((t, e) => { 0 != e && (n[t.replace(/\/(\:)?/ig, "")] = i[e]?.replace("/", "")) }) }), n } export function useQueries() { let t = new URLSearchParams(window.location.search); return { get: e => t.get(e) } } Array.prototype.at = function (t) { return t >= 0 ? this[t] : this[this.length + t] }, Array.prototype.remove = function (...t) { for (let e = 0; e < t.length; e++)t[e] >= 0 ? this[t[e]] = null : this[this.length + t[e]] = null; return this.filter(t => null !== t) }; export function random(t) { return Math.trunc(Math.random() * t) } export function cloneObject(t) { let e = {}; return Object.keys(t).forEach(r => { e[r] = t[r] }), e } export function OTP(t) { let e = []; for (let r = 0; r < t; r++)e.push(random(10)); return e.join("") } export function uniqueID() { return crypto.randomUUID() } export function scrollTo(t) { t.id ? location.href = `#${t.id}` : (t.id = "scrollTo-function", location.href = `#${t.id}`, t.removeAttribute("id")) } export function scrollToRoot(t) { location.href = `#${t}` } export function repeatAsArray(t, e) { return Array(e).fill(t) } export function copyToClipboard(t) { return navigator.clipboard.writeText(t) } export function createBlobFileAs(t, e) { try { return new Blob([t], { type: e }) } catch (r) { throw Error(`${r.message}`) } } export function transformToNumInput(t) { t.value = t.value.split(/\D+/ig).join("") } export function makeAppResponsive(t) { let e = document.querySelector(t); if (!e) throw Error(`Your element root "${t}" is ${e}`); e.style.height = `${window.innerHeight}px`, window.addEventListener("resize", () => e.style.height = `${window.innerHeight}px`) } export function addClickClass(t, e) { t.classList.add(e), t.addEventListener("animationend", () => { t.classList.remove(e) }) } export function getCurrentDate() { let t = new Date; return t.toLocaleString() } export function isHTMLElement(t) { return t instanceof HTMLElement } export function isHTMLInputElement(t) { return t instanceof HTMLInputElement } export function isFragment(t) { return t instanceof DocumentFragment } export function isFunction(t) { return "function" == typeof t } export function isString(t) { return "string" == typeof t } export function isArray(t) { return t instanceof Array } export function isUndefined(t) { return void 0 === t } export async function post({ url: t, data: e = {}, json: r = !0, headers: n = { "content-type": "Application/json" } }) { try { let a = await fetch(t, { method: "POST", headers: n, body: JSON.stringify(e) }); return r ? await a.json() : await a.text() } catch (i) { throw Error(i.message) } } export async function get({ url: t, headers: e }) { try { return await fetch(t, { method: "GET", headers: e }) } catch (r) { throw Error(r.message) } } export async function put({ url: t, headers: e, data: r }) { try { return await fetch(t, { method: "PUT", headers: e, body: JSON.stringify(r) }) } catch (n) { throw Error(n.message) } } export function isValidEmail(t) { let e = t?.trim().match(/\w+(\.\w+)?@\w+\.\w+$/ig), r = e?.join("")?.match(/\.\w+/ig); return e ? r && ".com" != r[r.length - 1] ? { valid: !1, msg: "We just accept .com" } : { valid: !0, type: "email", msg: "Email is valid" } : { valid: !1, msg: "Email is not a valid" } } export function isValidName(t) { let e = t?.trim().match(/[\s+|\W+]/g); return e || "" === t?.trim() || !t ? { valid: !1, msg: "Invalid name" } : { valid: !0, type: "name", data: name, msg: "Valid name" } } export function isValidDate(t) { let e = new Date(t); return +e.getFullYear > +new Date().getFullYear() || "Invalid Date" === e.toLocaleDateString() ? { valid: !1, msg: "Invalid Date..!" } : { valid: !0, msg: "Valid Date" } } export function isValidPassword(t) { let e = t.trim(), r = e?.match(/[^a-z0-9\.\s+]/ig), n = e?.match(/[0-9]/ig), a = e?.match(/[A-Z]/ig), i = e?.match(/[a-z]/ig), o = e?.match(/[\s+]/ig); switch (!0) { case !e: return { valid: !1, msg: "Password must not be empty" }; case !a || a.length < 1: return { valid: !1, msg: "Password must be at least 1 capital letter" }; case !i || i.length < 1: return { valid: !1, msg: "Password must be at least 1 small letter" }; case !n || n.length < 4: return { valid: !1, msg: "Password must be at least 4 digits" }; case !r: return { valid: !1, msg: "Password must have special characters" }; case null !== o: return { valid: !1, msg: "Password must not have spaces" }; case e.length < 8: return { valid: !1, msg: "Password must be at least 8 characters" }; default: return { valid: !0, msg: "Password is valid" } } } export function isValidRePassword(t, e) { return e == t ? { valid: !0, data: e.trim(), msg: "valid" } : { valid: !1, msg: "Re password does not match" } } export function encode(t, e = "") { t += e; let r = new TextEncoder().encode(encodeURIComponent(t)), n = r.reduce((t, e) => t + e); return btoa(encodeURI(n.toString())) } export function compare({ comparedText: t, comparedEncodedText: e, password: r = "" }) { return encode(t, r) === e ? { ok: !0, msg: "It is matched" } : { ok: !1, msg: "It is not matched" } } export class CocktailDB { constructor(t = "string") { this.updateI = 1, this.dbname = t, this.handlers = { doRequest: async (e = () => { }) => { let r = indexedDB.open(t, this.updateI - 1); return new Promise((t, n) => { r.addEventListener("success", function (r) { t(e(this.result)) }), r.addEventListener("error", function () { n(Error("Error : " + this.error)) }) }) }, async createObjectStore(t, e) { e.addEventListener("upgradeneeded", function (e) { this.result.createObjectStore(t, { keyPath: "id", autoIncrement: !0 }) }), e.addEventListener("success", function () { this.result.close() }) }, async returnData(t) { try { return new Promise((e, r) => { t.addEventListener("success", function () { e(this.result) }), t.addEventListener("error", function () { r(this.errorCode) }) }) } catch (e) { throw Error(e.message) } }, findHandler: async (t, e, r) => { try { return await this.handlers.doRequest(async n => { let a = n.transaction(t, "readwrite").objectStore(t).getAll(), i = await this.handlers.returnData(a), o = []; return e ? (i.forEach(t => { for (let r in t) for (let n in e) r == n && t[r] == e[n] && o.push(t) }), r(o)) : r(i) }) } catch (n) { throw Error(n.message) } } } } async createCollction(t) { let e = indexedDB.open(this.dbname, this.updateI); this.updateI++, this.handlers.createObjectStore(t, e); let r = { set: async e => { try { return await this.handlers.doRequest(async n => { let a = await r.find(); e.id = a.at(-1) ? a[a.length - 1].id + 1 : 0, n.transaction(t, "readwrite").objectStore(t).add(e), n.close() }), await r.find() } catch (n) { throw Error(n.message) } }, findOne: async e => { try { if (e instanceof Object && !Object.entries(e)[0]) throw Error("query must not be an empty"); if ("object" != typeof e) throw Error("query type must be an object"); return await this.handlers.findHandler(t, e, t => t[0]) } catch (r) { throw Error(r.message) } }, findOneAndUpdate: async (e, n) => { try { this.handlers.doRequest(async a => { let i = await r.findOne(e); n.id = i.id, a.transaction(t, "readwrite").objectStore(t).put(n) }) } catch (a) { throw Error(a.message) } }, find: async e => { try { if (e && "object" != typeof e) throw Error("Query type must be an object like that => {Query}"); return await this.handlers.findHandler(t, e, t => t) } catch (r) { throw Error(r.message) } }, findAndUpdate: async (e, n) => { try { this.handlers.doRequest(async a => { let i = await r.find(e); for (let o = 0; o < i.length; o++)n.id = i[o].id, a.transaction(t, "readwrite").objectStore(t).put(n) }) } catch (a) { throw Error(a.message) } }, delete: async e => { try { this.handlers.doRequest(async n => { let a = await r.find(e); for (let i = 0; i < a.length; i++)n.transaction(t, "readwrite").objectStore(t).delete(a[i].id) }) } catch (n) { throw Error(n.message) } }, deleteOne: async e => { try { return await this.handlers.doRequest(async n => { let a = await r.findOne(e); return n.transaction(t, "readwrite").objectStore(t).delete(a.id), await r.find() }) } catch (n) { throw Error(n.message) } } }; return r } deleteDatabase() { indexedDB.deleteDatabase(dbname) } } export class TelegramBot { constructor(t = "string", e = "string") { this.token = t, this.chatId = e } async compressURL(t) { let e = `https://tinyurl.com/api-create.php?url=${await this.getFileFromBot(t)}`, r = await (await fetch(e)).text(); return { compresedURl: r, normalUrl: await this.getFileFromBot(t), id: t, ok: !0 } } async getFileFromBot(t) { try { let e = `https://api.telegram.org/bot${this.token}/getFile?file_id=${t}`, r = await (await fetch(e)).json(), n = r.result.file_path, a = `https://api.telegram.org/file/bot${token}/${n}`; return a } catch (i) { throw Error(i.message) } } async sendFile(t = Blob) { try { let e = new FormData; e.append("document", t, `${t.name}`), e.append("chat_id", this.chatId); let r = await (await fetch(`https://api.telegram.org/bot${this.token}/sendDocument`, { method: "POST", body: e })).json(), n = r.result.document.file_id; return { ok: !0, id: n, fileUrl: await this.getFileFromBot(n) } } catch (a) { return { ok: !1, msg: `Faild to upload : ${a.message}`, url: "No url Fethced" } } } async sendImage(t = Blob) { return await this.sendFile(t) } async sendVideo(t = Blob) { try { let e = new FormData; e.append("video", t, `${t.name}`); let r = `https://api.telegram.org/bot${this.token}/sendVideo?chat_id=${this.chatId}`, n = await (await fetch(r, { method: "POST", body: e })).json(), a = n.result.video.file_id; return { ok: !0, id: a, url: await this.getFileFromBot(a) } } catch (i) { return { ok: !1, msg: `Faild to upload  : ${i.message}`, url: "No url Fethced" } } } async sendAudio(t = Blob) { try { let e = `https://api.telegram.org/bot${this.token}/sendAudio?chat_id=${this.chatId}`, r = new FormData; r.append("audio", t, `${t.name}`); let n = await (await fetch(e, { method: "POST", body: r })).json(), a = n.result.audio.file_id; return { ok: !0, id: a, url: await this.compressURL(a) } } catch (i) { return { ok: !1, msg: `Faild to upload : ${i.message}`, url: "No url Fethced" } } } async sendMessage(t = "string") { try { let e = `https://api.telegram.org/bot${this.token}/sendMessage?chat_id=${this.chatId}&text=${t}`, r = await (await fetch(e)).json(); return r } catch (n) { return { ok: !1, msg: `Faild to upload : ${n.message}`, url: "No url Fethced" } } } async getUpdates() { return await (await fetch(`https://api.telegram.org/bot${this.token}/getUpdates`)).json() } async getMessages() { return (await this.getUpdates()).result[0].message } }